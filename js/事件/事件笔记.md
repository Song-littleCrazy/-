事件
---
 
JavaScript和HTML之间的交互是通过**事件**实现的。

事件就是文档或浏览器窗口中发生的一些特定的交互瞬间。 可以用**侦听器**（处理程序）来预定事件，以便事件发生时执行相应的代码。

事件流——描述从页面中接收事件的顺序。
-

 - 事件冒泡：
  - 事件开始由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。
  ![事件冒泡示意图](https://i.imgur.com/yjoc1xE.png)
  
 - 事件捕获：
  - 思想 ：不太具体的节点应该更早接收到事件，而最具提的节点应该最后接收到事件。
  ![](https://i.imgur.com/BbmUdDC.png)


 - DOM事件流：
  - 事件捕获阶段——处于目标阶段——事件冒泡阶段。
  - 在DOM事件流中，实际的目标（`<div>元素`）在捕获阶段不会接收到事件。这意味着在捕获阶段，事件从`document到<html>再到<body>`后就停止了。下一个阶段是“处于目标”阶段，于是事件在`<div>`上发生，并在事件处理中被堪称冒泡阶段的一部分。然后冒泡阶段发生，事件又传播回文档。
  
   ![](https://i.imgur.com/kmddwTi.png)


事件处理程序——相应某个事件的函数（onXX）
-

 1. **html事件处理程序**——直接在html中定义一个事件：

   - 优点：
     - 这样会创建一个封装着元素属性值的函数，这个函数中有一个局部变量event（事件对象），通过event变量，可以直接访问事件对象：`<input type="button" value="Click Me" onclick="alert(event.type)"> `


     - 可以直接引用this，this值等于事件的目标元素：    `<input type="button" value="Click Me" onclick="alert(this.value)"> `


     - 扩展作用域：    `<input type="text" name="username" value=""> `
     `<input type="button" value="Echo Username" onclick="alert(username.value)"> `
    
   - 缺点：

     - 避免html中的事件和js中的函数存在的时差问题，可以把html事件处理程序封装在 `try-catch` 块中：`<input type="button" value="Click Me" onclick="try{showMessage();}catch(ex){}"> `


     - 因html和javascript代码紧密耦合，若要更换事件处理程序就要改两个地方（html+js)，所以尽量少用html事件处理程序，而使用js指定事件处理程序


 2. **Dom0事件处理程序**——将一个函数赋值给一个事件处理程序属性：

   - 每个元素（包括window和document）都有自己的事件处理程序属性，这些属性全部小写，将这种属性的值设置为一个函数，就可以指定事件处理程序：
   
    `var btn = document.getElementById("myBtn"); `

    `btn.onclick = function(){      alert("Clicked");     }; `

   - 删除指定的事件处理程序： `btn.onclick = null;`

   - 缺点：如果事件位于按钮后面，可以能在一段时间内单机都没有反应。

 3.  **Dom0事件处理程序**——定义addEventListener()和removeEventListener()方法：

   - 所有dom节点都包含这两个方法，且接收三个参数：要处理的事件名，作为事件处理程序的函数和一个布尔值（true——在捕获阶段调用事件处理程序；false——在冒泡阶段调用事件处理程序）。

    `var btn = document.getElementById("myBtn"); `

    `btn.addEventListener("click", function(){     alert(this.id);     }, false); `

    `btn.addEventListener("click", function(){  alert("Hello world!"); }, false);` 

   - 移除事件处理程序时，必须要和调用的函数一样，所以函数必须单独定义，才会被删除：
   
    `var btn = document.getElementById("myBtn"); `

    `var handler = function(){      alert(this.id);    }; `

    `btn.addEventListener("click", handler, false); `

    `//这里省略了其他代码`

    `btn.removeEventListener("click", handler, false); //有效！`

    
   - 优点：
   
     - 可以添加多个事件处理程序 
     
   - 注意：
     - 大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段，这样可以最大限度的兼容个中浏览器。
     - IE9、Firefox、Safari、Chrome 和 Opera 支持 DOM2 级事件处理程序。
 
 4.  **IE事件处理程序**——attachEvent()和 detachEvent()：
 
   - 两个参数：事件处理程序名称与事件处理程序函数。（默认添加到冒泡阶段）

   - 添加多个attachEvent（）时，以添加顺序的相反顺序被触发，先出现hello world，然后才是clicked：
   
    `var btn = document.getElementById("myBtn"); `
    
    `btn.attachEvent("onclick", function(){  alert("Clicked"); }); `
    
    `btn.attachEvent("onclick", function(){  alert("Hello world!"); }); `
    
   - 区别：
     - dom0——事件处理程序会在其所属元素的作用域内运行；
     - attachEvent()——在全局作用域中运行，this=window。

 5.  **跨浏览器**——把上面的方法综合运用


事件对象
-

在触发dom上的某个事件时，会产生一个事件对象event，这个对象中包含着所有与事件有关的信息，包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。

  1. dom中的事件对象：
     
   - event对象作为window对象的一个属性存在。

  2. ie

    - IE中的event对象又几种不同的方式，取决于指定事件处理程序的方法。


  3. 跨浏览器


事件类型
-

鼠标事件：

获取位置坐标：



内存和性能：
-

在js中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能。导致的原因如下:

 - 首先：每个函数都是对象，都会占用内存；内存中的对象越多，性能就越差。

 - 其次：必须事先指定所有事件处理程序而导致的DOM访问次数，会延迟整个页面的交互就绪时间。

提升性能的方法如下：

 **1. 事件委托**：

   - 对“事件处理程序过多”问题的解决方案就是事件委托。事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。也就是说，可以为整个页面指定一个onclick事件处理程序，而不必给每个可单击的元素分别添加事件处理程序。

-

    `<ul id="myLinks"> 
     <li id="goSomewhere">Go somewhere</li> 
     <li id="doSomething">Do something</li> 
     <li id="sayHi">Say hi</li> 
    </ul>` 

-

    `var EventUtil={
    	
     addHandler:function(element,type,handler){ //添加事件
      if(element.addEventListener){ 
     element.addEventListener(type,handler,false);  //使用DOM2级方法添加事件
      }else if(element.attachEvent){//使用IE方法添加事件
     element.attachEvent("on"+type,handler);
      }else{
     element["on"+type]=handler;  //使用DOM0级方法添加事件
      }
       },  
    
       removeHandler:function(element,type,handler){  //取消事件
      if(element.removeEventListener){
     element.removeEventListener(type,handler,false);
      }else if(element.detachEvent){
     element.detachEvent("on"+type,handler);
      }else{
     element["on"+type]=null;
      }
       },
    
       getEvent:function(event){  //使用这个方法跨浏览器取得event对象
      return event?event:window.event;
       },
    	
       getTarget:function(event){  //返回事件的实际目标
      return event.target||event.srcElement;
       },
     }`

-

    var list = document.getElementById("myLinks"); 

    EventUtil.addHandler(list, "click", function(event){ 

     event = EventUtil.getEvent(event); 

     var target = EventUtil.getTarget(event);`

     switch(target.id){ 

     case "doSomething": document.title = "I changed the document's title"; break;

     case "goSomewhere": location.href = "http://www.wrox.com"; break;

     case "sayHi": alert("hi"); break; } });
      
 

   - 若可行的话，可以考虑为document对象添加一个事件处理程序，用于处理页面上发生的某种特定类型的事件。优点如下：

      - document对象很块就可以访问，而且可以在页面生命周期的任何点上为它添加事件处理程序。换句话说，只要可单击的元素呈现在页面上，就可以立即具备适当的功能。
      - 在页面中设置事件处理程序所需的事件更少。
      - 整个页面占用的内存空间更少，能够提升整体性能。

     - 最适合采用事件委托技术的事件： click、mousedown、mouseup、keydown、keyup、keypress。


**2. 移除事件处理程序**：

将事件处理程序指定给元素时，运行中的浏览器代码与支持页面交互的JavaScript代码之间就会建立一个连接。这种连接越多，页面执行起来就越慢。

 - **两种情况会导致“空事件处理程序”——造成web应用程序内存与性能问题的主要原因**：
   - 从文档中移除带有事件处理程序的元素： 
     - 删除按钮也可以阻止事件冒泡。
     - removeChild()和repalceChild()。
     - 使用innerHTML，通过btn.onclick = null移除按钮的事件处理程序。确保内存被再次利用，而从dom中移除按钮页干净利落：

-

    <div id="myDiv"> 
     <input type="button" value="Click Me" id="myBtn"> 
    </div> 
    <script type="text/javascript"> 
     var btn = document.getElementById("myBtn"); 
    btn.onclick = function(){ 
     //先执行某些操作

     btn.onclick = null; //移除事件处理程序

     document.getElementById("myDiv").innerHTML = "Processing..."; 
     }; 
    </script> 

-

   - 卸载页面：
     - 如果在卸载页面之前没有清理干净事件处理程序，那他们就会滞留在内存中。
     - 最好的做法：在页面卸载之前，先通过onunload事件处理程序移除所有事件处理程序（即：只要通过onload事件处理程序添加的东西，最后都要通过onunload事件处理程序移除）。

问题补充
---

